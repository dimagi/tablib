% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{mathpazo}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{krstyle}

\title{Tablib Documentation}
\date{February 10, 2011}
\release{0.9.3}
\author{Kenneth Reitz}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.64,0.00,0.00}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{0.94,0.16,0.16}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.56,0.35,0.01}{##1}}}
\def\PYG@tok@gp{\def\PYG@tc##1{\textcolor[rgb]{0.45,0.33,0.20}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.60,0.00,0.00}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.77,0.63,0.00}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.50,0.50,0.50}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.64,0.00,0.00}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.60,0.00,0.00}{##1}}}
\def\PYG@tok@cs{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.56,0.35,0.01}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.35,0.01}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\def\PYG@tc##1{\textcolor[rgb]{0.81,0.36,0.00}{##1}}}
\def\PYG@tok@ld{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@nl{\def\PYG@tc##1{\textcolor[rgb]{0.96,0.47,0.00}{##1}}}
\def\PYG@tok@nn{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@nc{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@nd{\def\PYG@tc##1{\textcolor[rgb]{0.50,0.50,0.50}{##1}}}
\def\PYG@tok@ne{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.80,0.00,0.00}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@nx{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@si{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@py{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.60,0.00,0.00}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.40,0.64}{##1}}}
\def\PYG@tok@x{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.56,0.35,0.01}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.35,0.16,0.00}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.56,0.35,0.01}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@g{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@err{\def\PYG@tc##1{\textcolor[rgb]{0.64,0.00,0.00}{##1}}\def\PYG@bc##1{\fcolorbox[rgb]{0.94,0.16,0.16}{1,1,1}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.60,0.00,0.00}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.60,0.00,0.00}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.60,0.00,0.00}{##1}}}
\def\PYG@tok@l{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@n{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@p{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@kp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@w{\let\PYG@ul=\underline\def\PYG@tc##1{\textcolor[rgb]{0.97,0.97,0.97}{##1}}}
\def\PYG@tok@kt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.38}{##1}}}
\def\PYG@tok@se{\def\PYG@tc##1{\textcolor[rgb]{0.31,0.60,0.02}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.56,0.35,0.01}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Tablib is an {\hyperref[intro:mit]{\emph{MIT Lisenced}}} format-agnostic tabular dataset library, written in Python. It allows you to import, export, and manipulate tabular data sets. Advanced features include, segregation, dynamic columns, tags \& filtering, and seamless format import \& exmport.

I recommend you start with {\hyperref[install:install]{\emph{Installation}}}.


\part{User's Guide}
\label{index:user-s-guide}\label{index:tablib-pythonic-tabular-data}
This part of the documentation, which is mostly prose, begins with some background information about Tablib, then focuses on step-by-step instructions for getting the most out of your datasets.


\chapter{Introduction}
\label{intro:introduction}\label{intro:intro}\label{intro::doc}
This part of the documentation covers all the interfaces of Tablib.
Tablib is a format-agnostic tabular dataset library, written in Python. It allows you to Pythonically import, export, and manipulate tabular data sets. Advanced features include, segregation, dynamic columns, tags / filtering, and seamless format import/exmport.


\section{Philosphy}
\label{intro:philosphy}
Tablib was developed with a few \index{Python Enhancement Proposals!PEP 20}\href{http://www.python.org/dev/peps/pep-0020}{\textbf{PEP 20}} idioms in mind.
\begin{enumerate}
\item {} 
Beautiful is better than ugly.

\item {} 
Explicit is better than implicit.

\item {} 
Simple is better than complex.

\item {} 
Complex is better than complicated.

\item {} 
Readability counts.

\end{enumerate}

All contributions to Tablib should keep these important rules in mind.


\section{MIT License}
\label{intro:mit}\label{intro:mit-license}
A large number of open source projects you find today are \href{http://www.opensource.org/licenses/gpl-license.php}{GPL Licensed}. While the GPL certianly has essential applications, it should most certianly not be your go-to license for your next open source project.

A project that is released as GPL cannot be usd in any commercial product without the product itself also being offered as open source. The MIT and BSD licenses are great alternatives to the GPL that allow your open-source software to be used in proprietary, closed-source software.

Tablib is released under terms of \href{http://www.opensource.org/licenses/mit-license.php}{The MIT License}.


\section{Pythons Supported}
\label{intro:pythons-supported}\label{intro:pythonsupport}
At this time, the following Python platforms are officially supported:
\begin{itemize}
\item {} 
Python 2.6

\item {} 
Python 2.7

\end{itemize}

Support for other Pythons will be rolled out soon.

Now, go {\hyperref[install:install]{\emph{Install Tablib}}}.


\chapter{Installation}
\label{install:installation}\label{install::doc}\label{install:install}
This part of the documentation covers the installation of Tablib. The first step to using any software package is getting it properly installed. Please read this section carefully, or you may miss out on some nice  \emph{speed enhancments}.


\section{Installing Tablib}
\label{install:installing-tablib}\label{install:installing}
To install Tablib, it only takes one simple command.

\begin{Verbatim}[commandchars=@\[\]]
@$ pip install tablib
\end{Verbatim}

Or, if you must:

\begin{Verbatim}[commandchars=@\[\]]
@$ easy@_install tablib
\end{Verbatim}

But, you really shouldn't do that.


\section{Download the Source}
\label{install:download-the-source}
You can also install tablib from source. The latest release (0.9.3) is available from GitHub.
\begin{itemize}
\item {} 
\href{http://github.com/kennethreitz/tablib/tarball/master}{tarball}

\item {} 
\href{http://github.com/kennethreitz/tablib/zipball/master}{zipball}

\end{itemize}

Once you have a copy of the source, you can embed it in your Python package, or install it into your site-packages easily.

\begin{Verbatim}[commandchars=@\[\]]
@$ python setup.py install
\end{Verbatim}

To download the full source history from Git, see {\hyperref[development:scm]{\emph{Source Control}}}.


\subsection{Speed Extentions}
\label{install:speed-extentions}\label{install:id1}New in version 0.8.5.
Tablib is partially dependent on the \textbf{pyyaml}, \textbf{simplejson}, and \textbf{xlwt} modules. To reduce installation issues, fully integrated versions of all required libraries are included in Tablib.

However, if performance is important to you (and it should be), you can install  \textbf{pyyaml} with C extentions from PyPi.

\begin{Verbatim}[commandchars=@\[\]]
@$ pip install PyYAML
\end{Verbatim}

If you're using Python 2.5 (currently unsupported), you should also install the \textbf{simplejson} module. If you're using Python 2.6+, the built-in \textbf{json} module is already optimized and in use.

\begin{Verbatim}[commandchars=@\[\]]
@$ pip install simplejson
\end{Verbatim}


\subsection{Staying Updated}
\label{install:staying-updated}\label{install:updates}
The latest version of Tablib will always be available here:
\begin{itemize}
\item {} 
PyPi: \href{http://pypi.python.org/pypi/tablib/}{http://pypi.python.org/pypi/tablib/}

\item {} 
GitHub: \href{http://github.com/kennethreitz/tablib/}{http://github.com/kennethreitz/tablib/}

\end{itemize}

When a new version is available, upgrading is simple.

\begin{Verbatim}[commandchars=@\[\]]
@$ pip install tablib --upgrade
\end{Verbatim}

Now, go get a {\hyperref[tutorial:quickstart]{\emph{Quick Start}}}.


\chapter{Quickstart}
\label{tutorial::doc}\label{tutorial:quickstart}\label{tutorial:id1}\phantomsection\label{tutorial:module-tablib}\index{tablib (module)}
Eager to get started? This page gives a good introduction in how to get started with Tablib. This assumes you already have Tablib installed. If you do not, head over to the {\hyperref[install:install]{\emph{Installation}}} section.

First, make sure that:
\begin{itemize}
\item {} 
Tablib is {\hyperref[install:install]{\emph{installed}}}

\item {} 
Tablib is {\hyperref[install:updates]{\emph{up-to-date}}}

\end{itemize}

Lets gets started with some simple use cases and examples.


\section{Creating a Dataset}
\label{tutorial:creating-a-dataset}
A {\hyperref[api:tablib.Dataset]{\code{Dataset}}} is nothing more than what its name implies—a set of data.

Creating your own instance of the {\hyperref[api:tablib.Dataset]{\code{tablib.Dataset}}} object is simple.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

You can now start filling this {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object with data.

\begin{notice}{note}{Example Context}

From here on out, if you see \code{data}, assume that it's a fresh {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object.
\end{notice}


\section{Adding Rows}
\label{tutorial:adding-rows}
Let's say you want to collect a simple list of names.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\# collection of names}
\PYG{n}{names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Kenneth Reitz}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Bessie Monke}\PYG{l+s}{'}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{names}\PYG{p}{:}
    \PYG{c}{\# split name appropriately}
    \PYG{n}{fname}\PYG{p}{,} \PYG{n}{lname} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\# add names to Dataset}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{lname}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

You can get a nice, Pythonic view of the dataset at any time with {\hyperref[api:tablib.Dataset.dict]{\code{Dataset.dict}}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{dict}
\PYG{g+go}{[('Kenneth', 'Reitz'), ('Bessie', 'Monke')]}
\end{Verbatim}


\section{Adding Headers}
\label{tutorial:adding-headers}
It's time enhance our {\hyperref[api:tablib.Dataset]{\code{Dataset}}} by giving our columns some titles. To do so, set {\hyperref[api:tablib.Dataset.headers]{\code{Dataset.headers}}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{.}\PYG{n}{headers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{First Name}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Last Name}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

Now our data looks a little different.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{dict}
\PYG{g+go}{[\PYGZob{}'Last Name': 'Reitz', 'First Name': 'Kenneth'\PYGZcb{}, \PYGZob{}'Last Name': 'Monke', 'First Name': 'Bessie'\PYGZcb{}]}
\end{Verbatim}


\section{Adding Columns}
\label{tutorial:adding-columns}
Now that we have a basic {\hyperref[api:tablib.Dataset]{\code{Dataset}}} in place, let's add a column of \textbf{ages} to it.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{col}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,} \PYG{n}{header}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Age}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

Let's view the data now.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{dict}
\PYG{g+go}{[\PYGZob{}'Last Name': 'Reitz', 'First Name': 'Kenneth', 'Age': 22\PYGZcb{}, \PYGZob{}'Last Name': 'Monke', 'First Name': 'Bessie', 'Age': 20\PYGZcb{}]}
\end{Verbatim}

It's that easy.


\section{Exporting Data}
\label{tutorial:exporting-data}
Tablib's killer feature is the ability to export your {\hyperref[api:tablib.Dataset]{\code{Dataset}}} objects into a number of formats.

\textbf{Comma-Seperated Values}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{csv}
\PYG{g+go}{Last Name,First Name,Age}
\PYG{g+go}{Reitz,Kenneth,22}
\PYG{g+go}{Monke,Bessie,20}
\end{Verbatim}

\textbf{JavaScript Object Notation}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{json}
\PYG{g+go}{[\PYGZob{}"Last Name": "Reitz", "First Name": "Kenneth", "Age": 22\PYGZcb{}, \PYGZob{}"Last Name": "Monke", "First Name": "Bessie", "Age": 20\PYGZcb{}]}
\end{Verbatim}

\textbf{YAML Ain't Markup Language}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{yaml}
\PYG{g+go}{- \PYGZob{}Age: 22, First Name: Kenneth, Last Name: Reitz\PYGZcb{}}
\PYG{g+go}{- \PYGZob{}Age: 20, First Name: Bessie, Last Name: Monke\PYGZcb{}}
\end{Verbatim}

\textbf{Microsoft Excel}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{xls}
\PYG{g+go}{\textless{}censored binary data\textgreater{}}
\end{Verbatim}


\section{Selecting Rows \& Columns}
\label{tutorial:selecting-rows-columns}
You can slice and dice your data, just like a standard Python list.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{('Kenneth', 'Reitz', 22)}
\end{Verbatim}

If we had a set of data consisting of thousands of rows, it could be useful to get a list of values in a column.
To do so, we access the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} as if it were a standard Python dictionary.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{First Name}\PYG{l+s}{'}\PYG{p}{]}
\PYG{g+go}{['Kenneth', 'Bessie']}
\end{Verbatim}

Let's find the average age.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ages} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Age}\PYG{l+s}{'}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{ages}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ages}\PYG{p}{)}
\PYG{g+go}{21.0}
\end{Verbatim}


\section{Removing Rows \& Columns}
\label{tutorial:removing-rows-columns}
It's easier than you could imagine.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{del} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Col Name}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{del} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{12}\PYG{p}{]}
\end{Verbatim}


\chapter{Advanced Usage}
\label{tutorial:advanced-usage}
This part of the documentation services to give you an idea that are otherwise hard to extract from the {\hyperref[api:api]{\emph{API Documentation}}}

And now for something completely different.


\section{Dynamic Columns}
\label{tutorial:dynamic-columns}\label{tutorial:dyncols}New in version 0.8.3.
Thanks to Josh Ourisman, Tablib now supports adding dynamic columns. A dynamic column is a single callable object (\emph{ie.} a function).

Let's add a dynamic column to our {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. In this example, we have a function that generates a random grade for our students.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}

\PYG{k}{def} \PYG{n+nf}{random\PYGZus{}grade}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""Returns a random integer for entry."""}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{100.0}\PYG{p}{)}

\PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{col}\PYG{o}{=}\PYG{p}{[}\PYG{n}{random\PYGZus{}grade}\PYG{p}{]}\PYG{p}{,} \PYG{n}{header}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Grade}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

Let's have a look at our data.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{yaml}
\PYG{g+go}{- \PYGZob{}Age: 22, First Name: Kenneth, Grade: 0.6, Last Name: Reitz\PYGZcb{}}
\PYG{g+go}{- \PYGZob{}Age: 20, First Name: Bessie, Grade: 0.75, Last Name: Monke\PYGZcb{}}
\end{Verbatim}

Let's remove that column.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{del} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Grade}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

When you add a dynamic column, the first argument that is passed in to the given callable is the current data row. You can use this to perform calculations against your data row.

For example, we can use the data available in the row to guess the gender of a student.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{guess\PYGZus{}gender}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""Calculates gender of given student data row."""}
    \PYG{n}{m\PYGZus{}names} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Kenneth}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Mike}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Yuri}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{f\PYGZus{}names} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Bessie}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Samantha}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Heather}\PYG{l+s}{'}\PYG{p}{)}

    \PYG{n}{name} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

    \PYG{k}{if} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{m\PYGZus{}names}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{'}\PYG{l+s}{Male}\PYG{l+s}{'}
    \PYG{k}{elif} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{f\PYGZus{}names}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{'}\PYG{l+s}{Female}\PYG{l+s}{'}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{'}\PYG{l+s}{Unknown}\PYG{l+s}{'}
\end{Verbatim}

Adding this function to our dataset as a dynamic column would result in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{yaml}
\PYG{g+go}{- \PYGZob{}Age: 22, First Name: Kenneth, Gender: Male, Last Name: Reitz\PYGZcb{}}
\PYG{g+go}{- \PYGZob{}Age: 20, First Name: Bessie, Gender: Female, Last Name: Monke\PYGZcb{}}
\end{Verbatim}


\section{Filtering Datasets with Tags}
\label{tutorial:filtering-datasets-with-tags}\label{tutorial:tags}New in version 0.9.0.
When constructing a {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object, you can add tags to rows by specifying the \code{tags} parameter.
This allows you to filter your {\hyperref[api:tablib.Dataset]{\code{Dataset}}} later. This can be useful so seperate rows of data based on
arbitrary criteria (\emph{e.g.} origin) that you don't want to include in your {\hyperref[api:tablib.Dataset]{\code{Dataset}}}.

Let's tag some students.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{students} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{students}\PYG{o}{.}\PYG{n}{headers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{first}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{last}\PYG{l+s}{'}\PYG{p}{]}

\PYG{n}{students}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Kenneth}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Reitz}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tags}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{male}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{technical}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{students}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Bessie}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Monke}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tags}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{female}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{creative}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Now that we have extra meta-data on our rows, we can use easily filter our {\hyperref[api:tablib.Dataset]{\code{Dataset}}}. Let's just see Male students.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{male}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{yaml}
\PYG{g+go}{- \PYGZob{}first: Kenneth, Last: Reitz\PYGZcb{}}
\end{Verbatim}

It's that simple. The original {\hyperref[api:tablib.Dataset]{\code{Dataset}}} is untouched.


\subsection{Excel Workbook With Multiple Sheets}
\label{tutorial:excel-workbook-with-multiple-sheets}
When dealine with a large number of {\hyperref[api:tablib.Dataset]{\code{Datasets}}} in spreadsheet format, it's quite common to group mulitple spreadsheets into a single Excel file, known as a Workbook. Tablib makes it extremely easy to build webooks with the handy, {\hyperref[api:tablib.Databook]{\code{Databook}}} class.

Let's say we have 3 different {\hyperref[api:tablib.Dataset]{\code{Datasets}}}. All we have to do is add then to a {\hyperref[api:tablib.Databook]{\code{Databook}}} object...

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{book} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Databook}\PYG{p}{(}\PYG{p}{[}\PYG{n}{data1}\PYG{p}{,} \PYG{n}{data2}\PYG{p}{,} \PYG{n}{data3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

... and export to Excel just like {\hyperref[api:tablib.Dataset]{\code{Datasets}}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{students.xls}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{wb}\PYG{l+s}{'}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{book}\PYG{o}{.}\PYG{n}{xls}\PYG{p}{)}
\end{Verbatim}

The resulting \textbf{students.xls} file will contain a seperate spreadsheet for each {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object in the {\hyperref[api:tablib.Databook]{\code{Databook}}}.

\begin{notice}{note}{Binary Warning}

Make sure to open the output file in binary mode.
\end{notice}


\section{Seperators}
\label{tutorial:seperators}\label{tutorial:id2}New in version 0.8.2.
When, it's often useful to create a blank row containing information on the upcomming data. So,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{daniel\PYGZus{}tests} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{11/24/09}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Math 101 Mid-term Exam}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mf}{56.}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{05/24/10}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Math 101 Final Exam}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mf}{62.}\PYG{p}{)}
\PYG{p}{]}

\PYG{n}{suzie\PYGZus{}tests} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{11/24/09}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Math 101 Mid-term Exam}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mf}{56.}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{05/24/10}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Math 101 Final Exam}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mf}{62.}\PYG{p}{)}
\PYG{p}{]}

\PYG{c}{\# Create new dataset}
\PYG{n}{tests} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{tests}\PYG{o}{.}\PYG{n}{headers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Date}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Test Name}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Grade}\PYG{l+s}{'}\PYG{p}{]}

\PYG{c}{\# Daniel's Tests}
\PYG{n}{tests}\PYG{o}{.}\PYG{n}{append\PYGZus{}seperator}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Daniel}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{s Scores}\PYG{l+s}{'}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{test\PYGZus{}row} \PYG{o+ow}{in} \PYG{n}{daniel\PYGZus{}tests}\PYG{p}{:}
   \PYG{n}{tests}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{test\PYGZus{}row}\PYG{p}{)}

\PYG{c}{\# Susie's Tests}
\PYG{n}{tests}\PYG{o}{.}\PYG{n}{append\PYGZus{}seperator}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Susie}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{s Scores}\PYG{l+s}{'}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{test\PYGZus{}row} \PYG{o+ow}{in} \PYG{n}{suzie\PYGZus{}tests}\PYG{p}{:}
   \PYG{n}{tests}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{test\PYGZus{}row}\PYG{p}{)}

\PYG{c}{\# Write spreadsheet to disk}
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{grades.xls}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{wb}\PYG{l+s}{'}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{tests}\PYG{o}{.}\PYG{n}{xls}\PYG{p}{)}
\end{Verbatim}

The resulting \textbf{tests.xls} will have the following layout:
\begin{quote}
\begin{description}
\item[{Daniel's Scores:}] \leavevmode\begin{itemize}
\item {} 
`11/24/09', `Math 101 Mid-term Exam', 56.

\item {} 
`05/24/10', `Math 101 Final Exam', 62.

\end{itemize}

\item[{Suzie's Scores:}] \leavevmode\begin{itemize}
\item {} 
`11/24/09', `Math 101 Mid-term Exam', 56.

\item {} 
`05/24/10', `Math 101 Final Exam', 62.

\end{itemize}

\end{description}
\end{quote}

\begin{notice}{note}{Format Support}

At this time, only {\hyperref[api:tablib.Dataset.xls]{\code{Excel}}} output supports seperators.
\end{notice}


\bigskip\hrule{}\bigskip


Now, go check out the {\hyperref[api:api]{\emph{API Documentation}}} or begin {\hyperref[development:development]{\emph{Tablib Development}}}.


\chapter{Development}
\label{development:development}\label{development::doc}\label{development:id1}
Tablib is under active development, and contributors are welcome.

If you have a feature request, suggestion, or bug report, please open a new issue on \href{http://github.com/kennethreitz/tablib/}{GitHub}. To submit patches, please send a pull request on \href{http://github.com/kennethreitz/tablib/}{GitHub}.

If you'd like to contribute, there's plenty to do. Here's a short todo list.
\begin{itemize}
\item {} 
Add seperator support to HTML out

\item {} 
Hooks System
- pre/post-append
- pre/post-import
- pre/post-export

\item {} 
Big Data

\item {} 
Backwards-compatible OrderedDict support

\item {} 
Write more exhausive unit-tests.

\item {} 
Write stress tests.

\item {} 
Make CSV write customizable.

\item {} 
Integrate django-tablib

\item {} 
Mention django-tablib in Documention

\item {} 
Dataset title usage in documentation (\#17)

\end{itemize}


\section{Design Considerations}
\label{development:design}\label{development:design-considerations}
Tablib was developed with a few \index{Python Enhancement Proposals!PEP 20}\href{http://www.python.org/dev/peps/pep-0020}{\textbf{PEP 20}} idioms in mind.
\begin{enumerate}
\item {} 
Beautiful is better than ugly.

\item {} 
Explicit is better than implicit.

\item {} 
Simple is better than complex.

\item {} 
Complex is better than complicated.

\item {} 
Readability counts.

\end{enumerate}

A few other things to keep in mind:
\begin{enumerate}
\item {} 
Keep your code DRY.

\item {} 
Strive to be as simple (to use) as possible.

\end{enumerate}


\section{Source Control}
\label{development:scm}\label{development:source-control}
Tablib source is controlled with \href{http://git-scm.org}{Git}, the lean, mean, distributed source control machine.

The repository is publicly accessable.
\begin{quote}

\code{git clone git://github.com/kennethreitz/tablib.git}
\end{quote}

The project is hosted both on \textbf{GitHub} and \textbf{git.kennethreitz.com}.
\begin{quote}
\begin{description}
\item[{GitHub:}] \leavevmode
\href{http://github.com/kennethreitz/tablib}{http://github.com/kennethreitz/tablib}

\item[{``Mirror'':}] \leavevmode
\href{http://git.kennethreitz.com/projects/tablib}{http://git.kennethreitz.com/projects/tablib}

\end{description}
\end{quote}


\subsection{Git Branch Structure}
\label{development:git-branch-structure}
Feature / Hotfix / Release branches follow a \href{http://nvie.com/posts/a-successful-git-branching-model/}{Successful Git Branching Model} . \href{http://github.com/nvie/gitflow}{Git-flow} is a great tool for managing the repository. I highly recommend it.
\begin{description}
\item[{\code{develop}}] \leavevmode
The ``next release'' branch. Likely unstable.

\item[{\code{master}}] \leavevmode
Current production release (0.9.3) on PyPi.

\item[{\code{gh-pages}}] \leavevmode
Current release of \href{http://tablib.org}{http://tablib.org}.

\end{description}

Each release is tagged.

When submitting patches, please place your feature/change in its own branch prior to opening a pull reqeust on \href{http://github.com/kennethreitz/tablib/}{GitHub}.


\section{Adding New Formats}
\label{development:newformats}\label{development:adding-new-formats}
Tablib welcomes new format additions! Format suggestions include:
\begin{itemize}
\item {} 
Tab Seperated Values

\item {} 
MySQL Dump

\item {} 
HTML Table

\end{itemize}


\subsection{Coding by Convention}
\label{development:coding-by-convention}
Tablib features a micro-framework for adding format support. The easiest way to understand it is to use it. So, let's define our own format, named \emph{xxx}.
\begin{enumerate}
\item {} 
Write a new format interface.
\begin{quote}

\code{tablib.core} follows a simple pattern for automatically utilizing your format throughout Tablib. Function names are crucial.

Example \textbf{tablib/formats/\_xxx.py}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{title} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{xxx}\PYG{l+s}{'}

\PYG{k}{def} \PYG{n+nf}{export\PYGZus{}set}\PYG{p}{(}\PYG{n}{dset}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{c}{\# returns string representation of given dataset}

\PYG{k}{def} \PYG{n+nf}{export\PYGZus{}book}\PYG{p}{(}\PYG{n}{dbook}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{c}{\# returns string representation of given databook}

\PYG{k}{def} \PYG{n+nf}{import\PYGZus{}set}\PYG{p}{(}\PYG{n}{dset}\PYG{p}{,} \PYG{n}{in\PYGZus{}stream}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{c}{\# populates given Dataset with given datastream}

\PYG{k}{def} \PYG{n+nf}{import\PYGZus{}book}\PYG{p}{(}\PYG{n}{dbook}\PYG{p}{,} \PYG{n}{in\PYGZus{}stream}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{c}{\# returns Databook instance}

\PYG{k}{def} \PYG{n+nf}{detect}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{c}{\# returns True if given stream is parsable as xxx}
\end{Verbatim}
\end{quote}

\end{enumerate}

\begin{notice}{note}{Excluding Support}

If the format excludes support for an import/export mechanism (\emph{eg.} {\hyperref[api:tablib.Dataset.csv]{\code{csv}}} excludes {\hyperref[api:tablib.Databook]{\code{Databook}}} support), simply don't define the respecive functions. Appropriate errors will be raised.
\end{notice}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Add your new format module to the \code{tablib.formats.avalable} tuple.

\item {} 
Add a mock property to the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} class with verbose \href{http://docutils.sourceforge.net/rst.html}{reStructured Text} docstring. This alleviates IDE confusion, and allows for pretty auto-generated \href{http://sphinx.pocoo.org}{Sphinx} documentation.

\item {} 
Write respective {\hyperref[development:testing]{\emph{tests}}}.

\end{enumerate}


\section{Testing Tablib}
\label{development:testing}\label{development:testing-tablib}
Testing is crucial to Tablib's stability. This stable project is used in production by many companies and developers, so it is important to be certian that every version released is fully operational. When developing a new feature for Tablib, be sure to write proper tests for it as well.

When developing a feature for Tablib, the easiest way to test your changes for potential issues is to simply run the test suite directly.

\begin{Verbatim}[commandchars=@\[\]]
@$ ./test@_tablib.py
\end{Verbatim}

\href{http://hudson.dev.java.net}{Hudson CI}, amongst other tools, supports Java's xUnit testing report format. \href{http://somethingaboutorange.com/mrl/projects/nose/}{Nose} allows us to generate our own xUnit reports.

Installing nose is simple.

\begin{Verbatim}[commandchars=@\[\]]
@$ pip install nose
\end{Verbatim}

Once installed, we can generate our xUnit report with a single command.

\begin{Verbatim}[commandchars=@\[\]]
@$ nosetests test@_tablib.py --with-xunit
\end{Verbatim}

This will generate a \textbf{nosetests.xml} file, which can then be analyzed.


\section{Continuous Integration}
\label{development:continuous-integration}\label{development:hudson}
Every commit made to the \textbf{develop} branch is automatically tested and inspected upon receipt with \href{http://hudson.dev.java.net}{Hudson CI}. If you have access to the main respository and broke the build, you will receive an email accordingly.

Anyone may view the build status and history at any time.
\begin{quote}

\href{http://git.kennethreitz.com/ci/}{http://git.kennethreitz.com/ci/}
\end{quote}

If you are trustworthy and plan to contribute to tablib on a regular basis, please contact \href{http://kennethreitz.com/contact-me/}{Kenneth Reitz} to get an account on the Hudson Server.

Additional reports will also be included here in the future, including \index{Python Enhancement Proposals!PEP 8}\href{http://www.python.org/dev/peps/pep-0008}{\textbf{PEP 8}} checks and stress reports for extremely large datasets.


\section{Building the Docs}
\label{development:docs}\label{development:building-the-docs}
Documentation is written in the powerful, flexible, and standard Python documentation format, \href{http://docutils.sourceforge.net/rst.html}{reStructured Text}.
Documentation builds are powered by the powerful Pocoo project, \href{http://sphinx.pocoo.org}{Sphinx}. The {\hyperref[api:api]{\emph{API Documentation}}} is mostly documented inline throught the module.

The Docs live in \code{tablib/docs}. In order to build them, you will first need to install Sphinx.

\begin{Verbatim}[commandchars=@\[\]]
@$ pip install sphinx
\end{Verbatim}

Then, to build an HTML version of the docs, simply run the following from the \textbf{docs} directory:

\begin{Verbatim}[commandchars=@\[\]]
@$ make html
\end{Verbatim}

Your \code{docs/\_build/html} directory will then contain an HTML representation of the documentation, ready for publication on most web servers.

You can also generate the documentation in \textbf{ebpub}, \textbf{latex}, \textbf{json}, \emph{\&c} similarly.

\begin{notice}{note}{GitHub Pages}

To push the documentation up to \href{http://pages.github.com}{GitHub Pages}, you will first need to run \href{http://github.com/michaeljones/sphinx-to-github}{sphinx-to-github} against your \code{docs/\_build/html} directory.

GitHub Pages are powered by an HTML generation system called \href{http://github.com/mojombo/jekyll}{Jeckyl}, which is configured to ignore files and folders that begin with ``\code{\_}'' (\emph{ie.} \textbf{\_static}).
\begin{quote}

and \href{http://github.com/michaeljones/sphinx-to-github}{sphinx-to-github}.
\end{quote}

Installing sphinx-to-github is simple.

\begin{Verbatim}[commandchars=@\[\]]
@$ pip install sphinx-to-github
\end{Verbatim}

Running it against the docs is even simpler.

\begin{Verbatim}[commandchars=@\[\]]
@$ sphinx-to-github @_build/html
\end{Verbatim}

Move the resulting files to the \textbf{gh-pages} branch of your repository, and push it up to GitHub.
\end{notice}


\bigskip\hrule{}\bigskip


Make sure to check out the {\hyperref[api:api]{\emph{API Documentation}}}.


\part{API Reference}
\label{index:api-reference}
If you are looking for information on a specific function, class or
method, this part of the documentation is for you.


\chapter{API}
\label{api:api}\label{api::doc}\label{api:id1}\phantomsection\label{api:module-tablib}\index{tablib (module)}
This part of the documentation covers all the interfaces of Tablib.  For
parts where Tablib depends on external libraries, we document the most
important right here and provide links to the canonical documentation.


\section{Dataset Object}
\label{api:dataset-object}\index{Dataset (class in tablib)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset}\pysiglinewithargsret{\strong{class }\code{tablib.}\bfcode{Dataset}}{\emph{*args}, \emph{**kwargs}}{}
The {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object is the heart of Tablib. It provides all core
functionality.

Usually you create a {\hyperref[api:tablib.Dataset]{\code{Dataset}}} instance in your main module, and append
rows and columns as you collect data.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{headers} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{name}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{age}\PYG{l+s}{'}\PYG{p}{)}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{age}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{some\PYGZus{}collector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{age}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

You can also set rows and headers upon instantiation. This is useful if dealing
with dozens or hundres of {\hyperref[api:tablib.Dataset]{\code{Dataset}}} objects.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{headers} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{first\PYGZus{}name}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{last\PYGZus{}name}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{John}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Adams}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{George}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Washington}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{o}{*}\PYG{n}{data}\PYG{p}{,} \PYG{n}{headers}\PYG{o}{=}\PYG{n}{headers}\PYG{p}{)}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{*args} -- (optional) list of rows to populate Dataset

\item {} 
\textbf{headers} -- (optional) list strings for Dataset header row

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Format Attributes Definition}

If you look at the code, the various output/import formats are not
defined within the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. To add support for a new format, see
{\hyperref[development:newformats]{\emph{Adding New Formats}}}.
\end{notice}
\index{append() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.append}\pysiglinewithargsret{\bfcode{append}}{\emph{row=None}, \emph{col=None}, \emph{header=None}, \emph{tags=}\optional{}}{}
Adds a row or column to the {\hyperref[api:tablib.Dataset]{\code{Dataset}}}.
Usage is  {\hyperref[api:tablib.Dataset.insert]{\code{Dataset.insert}}} for documentation.

\end{fulllineitems}

\index{append\_separator() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.append_separator}\pysiglinewithargsret{\bfcode{append\_separator}}{\emph{text='-`}}{}
Adds a {\hyperref[tutorial:seperators]{\emph{seperator}}} to the {\hyperref[api:tablib.Dataset]{\code{Dataset}}}.

\end{fulllineitems}

\index{csv (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.csv}\pysigline{\bfcode{csv}}{}
A CSV representation of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. The top row will contain
headers, if they have been set. Otherwise, the top row will contain
the first row of the dataset.

A dataset object can also be imported by setting the {\hyperref[api:tablib.Dataset.csv]{\code{Dataset.csv}}} attribute.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{csv} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{age, first\PYGZus{}name, last\PYGZus{}name}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{90, John, Adams}\PYG{l+s}{'}
\end{Verbatim}

Import assumes (for now) that headers exist.

\end{fulllineitems}

\index{dict (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.dict}\pysigline{\bfcode{dict}}{}
A JSON representation of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. If headers have been
set, a JSON list of objects will be returned. If no headers have
been set, a JSON list of lists (rows) will be returned instead.

A dataset object can also be imported by setting the \emph{Dataset.json} attribute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{json} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{[\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{last\PYGZus{}name}\PYG{l+s}{"}\PYG{l+s}{: }\PYG{l+s}{"}\PYG{l+s}{Adams}\PYG{l+s}{"}\PYG{l+s}{,}\PYG{l+s}{"}\PYG{l+s}{age}\PYG{l+s}{"}\PYG{l+s}{: 90,}\PYG{l+s}{"}\PYG{l+s}{first\PYGZus{}name}\PYG{l+s}{"}\PYG{l+s}{: }\PYG{l+s}{"}\PYG{l+s}{John}\PYG{l+s}{"}\PYG{l+s}{\PYGZcb{}]}\PYG{l+s}{'}
\end{Verbatim}

\end{fulllineitems}

\index{filter() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.filter}\pysiglinewithargsret{\bfcode{filter}}{\emph{tag}}{}
Returns a new instance of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}}, excluding any rows
that do not contain the given {\hyperref[tutorial:tags]{\emph{tags}}}.

\end{fulllineitems}

\index{headers (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.headers}\pysigline{\bfcode{headers}}{}
An \emph{optional} list of strings to be used for header rows and attribute names.

This must be set manually. The given list length must equal {\hyperref[api:tablib.Dataset.width]{\code{Dataset.width}}}.

\end{fulllineitems}

\index{height (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.height}\pysigline{\bfcode{height}}{}
The number of rows currently in the {\hyperref[api:tablib.Dataset]{\code{Dataset}}}.
Cannot be directly modified.

\end{fulllineitems}

\index{html (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.html}\pysigline{\bfcode{html}}{}
A HTML table representation of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. If
headers have been set, they will be used as table headers.

..notice:: This method can be used for export only.

\end{fulllineitems}

\index{insert() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.insert}\pysiglinewithargsret{\bfcode{insert}}{\emph{index}, \emph{row=None}, \emph{col=None}, \emph{header=None}, \emph{tags=}\optional{}}{}
Inserts a row or column to the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} at the given index.

Rows and columns inserted must be the correct size (height or width).

The default behaviour is to insert the given row to the {\hyperref[api:tablib.Dataset]{\code{Dataset}}}
object at the given index. If the \code{col} parameter is given, however,
a new column will be insert to the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object instead.

You can also insert a column of a single callable object, which will
add a new column with the return values of the callable each as an
item in the column.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{col}\PYG{o}{=}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{)}
\end{Verbatim}

See {\hyperref[tutorial:dyncols]{\emph{Dynamic Columns}}} for an in-depth example.
Changed in version 0.9.0: If inserting a column, and {\hyperref[api:tablib.Dataset.headers]{\code{Dataset.headers}}} is set, the
header attribute must be set, and will be considered the header for
that row.New in version 0.9.0: If inserting a row, you can add {\hyperref[tutorial:tags]{\emph{tags}}} to the row you are inserting.
This gives you the ability to {\hyperref[api:tablib.Dataset.filter]{\code{filter}}} your
{\hyperref[api:tablib.Dataset]{\code{Dataset}}} later.
\end{fulllineitems}

\index{insert\_separator() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.insert_separator}\pysiglinewithargsret{\bfcode{insert\_separator}}{\emph{index}, \emph{text='-`}}{}
Adds a separator to {\hyperref[api:tablib.Dataset]{\code{Dataset}}} at given index.

\end{fulllineitems}

\index{json (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.json}\pysigline{\bfcode{json}}{}
A JSON representation of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. If headers have been
set, a JSON list of objects will be returned. If no headers have
been set, a JSON list of lists (rows) will be returned instead.

A dataset object can also be imported by setting the {\hyperref[api:tablib.Dataset.json]{\code{Dataset.json}}} attribute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{json} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{[\PYGZob{}age: 90, first\PYGZus{}name: }\PYG{l+s}{"}\PYG{l+s}{John}\PYG{l+s}{"}\PYG{l+s}{, liast\PYGZus{}name: }\PYG{l+s}{"}\PYG{l+s}{Adams}\PYG{l+s}{"}\PYG{l+s}{\PYGZcb{}]}\PYG{l+s}{'}
\end{Verbatim}

Import assumes (for now) that headers exist.

\end{fulllineitems}

\index{sort() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.sort}\pysiglinewithargsret{\bfcode{sort}}{\emph{col}, \emph{reverse=False}}{}
Sort a {\hyperref[api:tablib.Dataset]{\code{Dataset}}} by a specific column, given string (for
header) or integer (for column index). The order can be reversed by
setting \code{reverse} to \code{True}. 
Returns a new {\hyperref[api:tablib.Dataset]{\code{Dataset}}} instance where columns have been
sorted.

\end{fulllineitems}

\index{stack\_columns() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.stack_columns}\pysiglinewithargsret{\bfcode{stack\_columns}}{\emph{other}}{}
Stack two {\hyperref[api:tablib.Dataset]{\code{Dataset}}} instances together by
joining at the column level, and return a new
combined \code{Dataset} instance. If either \code{Dataset}
has headers set, than the other must as well.

\end{fulllineitems}

\index{stack\_rows() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.stack_rows}\pysiglinewithargsret{\bfcode{stack\_rows}}{\emph{other}}{}
Stack two {\hyperref[api:tablib.Dataset]{\code{Dataset}}} instances together by
joining at the row level, and return new combined
\code{Dataset} instance.

\end{fulllineitems}

\index{transpose() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.transpose}\pysiglinewithargsret{\bfcode{transpose}}{}{}
Transpose a {\hyperref[api:tablib.Dataset]{\code{Dataset}}}, turning rows into columns and vice
versa, returning a new \code{Dataset} instance. The first row of the
original instance becomes the new header row.

\end{fulllineitems}

\index{tsv (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.tsv}\pysigline{\bfcode{tsv}}{}
A TSV representation of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. The top row will contain
headers, if they have been set. Otherwise, the top row will contain
the first row of the dataset.

A dataset object can also be imported by setting the {\hyperref[api:tablib.Dataset.tsv]{\code{Dataset.tsv}}} attribute.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{tsv} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{age first\PYGZus{}name      last\PYGZus{}name}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{90   John    Adams}\PYG{l+s}{'}
\end{Verbatim}

Import assumes (for now) that headers exist.

\end{fulllineitems}

\index{width (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.width}\pysigline{\bfcode{width}}{}
The number of columns currently in the {\hyperref[api:tablib.Dataset]{\code{Dataset}}}.
Cannot be directly modified.

\end{fulllineitems}

\index{wipe() (tablib.Dataset method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.wipe}\pysiglinewithargsret{\bfcode{wipe}}{}{}
Removes all content and headers from the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object.

\end{fulllineitems}

\index{xls (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.xls}\pysigline{\bfcode{xls}}{}
An Excel Spreadsheet representation of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object, with {\hyperref[tutorial:seperators]{\emph{Seperators}}}. Cannot be set.

\begin{notice}{note}{Binary Warning}

{\hyperref[api:tablib.Dataset.xls]{\code{Dataset.xls}}} contains binary data, so make sure to write in binary mode:

\begin{Verbatim}[commandchars=@\[\]]
with open('output.xls', 'wb') as f:
    f.write(data.xls)'
\end{Verbatim}
\end{notice}

\end{fulllineitems}

\index{yaml (tablib.Dataset attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Dataset.yaml}\pysigline{\bfcode{yaml}}{}
A YAML representation of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} object. If headers have been
set, a YAML list of objects will be returned. If no headers have
been set, a YAML list of lists (rows) will be returned instead.

A dataset object can also be imported by setting the {\hyperref[api:tablib.Dataset.json]{\code{Dataset.json}}} attribute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{tablib}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{yaml} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{- \PYGZob{}age: 90, first\PYGZus{}name: John, last\PYGZus{}name: Adams\PYGZcb{}}\PYG{l+s}{'}
\end{Verbatim}

Import assumes (for now) that headers exist.

\end{fulllineitems}


\end{fulllineitems}



\section{Databook Object}
\label{api:databook-object}\index{Databook (class in tablib)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Databook}\pysiglinewithargsret{\strong{class }\code{tablib.}\bfcode{Databook}}{\emph{sets=None}}{}
A book of {\hyperref[api:tablib.Dataset]{\code{Dataset}}} objects.
\index{add\_sheet() (tablib.Databook method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Databook.add_sheet}\pysiglinewithargsret{\bfcode{add\_sheet}}{\emph{dataset}}{}
Adds given {\hyperref[api:tablib.Dataset]{\code{Dataset}}} to the {\hyperref[api:tablib.Databook]{\code{Databook}}}.

\end{fulllineitems}

\index{size (tablib.Databook attribute)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Databook.size}\pysigline{\bfcode{size}}{}
The number of the {\hyperref[api:tablib.Dataset]{\code{Dataset}}} objects within {\hyperref[api:tablib.Databook]{\code{Databook}}}.

\end{fulllineitems}

\index{wipe() (tablib.Databook method)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.Databook.wipe}\pysiglinewithargsret{\bfcode{wipe}}{}{}
Removes all {\hyperref[api:tablib.Dataset]{\code{Dataset}}} objects from the {\hyperref[api:tablib.Databook]{\code{Databook}}}.

\end{fulllineitems}


\end{fulllineitems}



\section{Functions}
\label{api:functions}\index{detect() (in module tablib)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.detect}\pysiglinewithargsret{\code{tablib.}\bfcode{detect}}{\emph{stream}}{}
Return (format, stream) of given stream.

\end{fulllineitems}

\index{import\_set() (in module tablib)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.import_set}\pysiglinewithargsret{\code{tablib.}\bfcode{import\_set}}{\emph{stream}}{}
Return dataset of given stream.

\end{fulllineitems}



\section{Exceptions}
\label{api:exceptions}\index{InvalidDatasetType (class in tablib)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.InvalidDatasetType}\pysigline{\strong{class }\code{tablib.}\bfcode{InvalidDatasetType}}{}
You're trying to add something that doesn't quite look right.

\end{fulllineitems}

\index{InvalidDimensions (class in tablib)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.InvalidDimensions}\pysigline{\strong{class }\code{tablib.}\bfcode{InvalidDimensions}}{}
You're trying to add something that doesn't quite fit right.

\end{fulllineitems}

\index{UnsupportedFormat (class in tablib)}

\begin{fulllineitems}
\phantomsection\label{api:tablib.UnsupportedFormat}\pysigline{\strong{class }\code{tablib.}\bfcode{UnsupportedFormat}}{}
You're trying to add something that doesn't quite taste right.

\end{fulllineitems}


Now, go start some {\hyperref[development:development]{\emph{Tablib Development}}}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
